<!DOCTYPE html>
<html>
  <head>
    <title>Satellite Graph Tool - Murfreesboro</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      #map {
        height: 600px;
        width: 100%;
        cursor: crosshair;
        background-color: #000;
      }
      /* High-visibility colors for Satellite Imagery */
      .node {
        fill: #00f2ff;
        stroke: #fff;
        stroke-width: 2px;
        cursor: pointer;
      }
      .node:hover {
        fill: #fff;
      }
      .link {
        stroke: #ffff00;
        stroke-width: 3px;
        opacity: 0.8;
        pointer-events: none;
      }
      #matrix-output {
        font-family: "Courier New", monospace;
        background: #222;
        color: #0f0;
        padding: 15px;
        margin-top: 10px;
        border-radius: 5px;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <h3>Adjacency Matrix (Live)</h3>
    <div id="matrix-output">Click the map to start building your graph...</div>

    <!-- <script>
        const map = L.map("map").setView([35.966944, -86.493056], 18);
    
        L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", {
            attribution: "Tiles © Esri",
            maxZoom: 20
        }).addTo(map);
    
        let nodes = [];
        let links = [];
        let sourceNode = null;
        let tempLine = null;
        let isDrawingLink = false; // Naya Lock variable
    
        L.svg().addTo(map);
        const svg = d3.select("#map").select("svg").style("pointer-events", "auto");
        const g = svg.append("g").attr("class", "leaflet-zoom-hide");
    
        function update() {
            // 1. Draw Links (Edges)
            const l = g.selectAll(".link").data(links);
            
            l.enter().append("line")
                .attr("class", "link")
                .merge(l) // Purani te navi lines dono update karo
                .attr("x1", d => map.latLngToLayerPoint([nodes[d.source].lat, nodes[d.source].lng]).x)
                .attr("y1", d => map.latLngToLayerPoint([nodes[d.source].lat, nodes[d.source].lng]).y)
                .attr("x2", d => map.latLngToLayerPoint([nodes[d.target].lat, nodes[d.target].lng]).x)
                .attr("y2", d => map.latLngToLayerPoint([nodes[d.target].lat, nodes[d.target].lng]).y);
    
            // 2. Draw Nodes (Same as before)
            const nodeGroups = g.selectAll(".node-group").data(nodes, d => d.id);
            const enterGroups = nodeGroups.enter().append("g").attr("class", "node-group");
    
            enterGroups.append("circle")
                .attr("class", "node")
                .attr("r", 12)
                .on("mousedown", (event, d) => {
                    event.stopPropagation();
                    L.DomEvent.stopPropagation(event);
                    isDrawingLink = true;
                    sourceNode = d.id;
                    tempLine = g.append("line").attr("class", "link").style("stroke-dasharray", "5,5");
                })
                .on("mouseup", (event, d) => {
                    event.stopPropagation();
                    if (sourceNode !== null && sourceNode !== d.id) {
                        const exists = links.some(l => 
                            (l.source === sourceNode && l.target === d.id) || 
                            (l.source === d.id && l.target === sourceNode)
                        );
                        if(!exists) {
                            links.push({ source: sourceNode, target: d.id });
                            updateMatrix(); 
                            update(); // <--- Line dikhan layi zaroori hai
                        }
                    }
                    setTimeout(() => { isDrawingLink = false; sourceNode = null; }, 100);
                    if (tempLine) tempLine.remove();
                });
    
            // Labels and Position updates...
            enterGroups.append("text").attr("dx", 16).attr("dy", 5).style("fill", "#00f2ff").text(d => "Node " + d.id);
            nodeGroups.merge(enterGroups).attr("transform", d => {
                const p = map.latLngToLayerPoint([d.lat, d.lng]);
                return `translate(${p.x},${p.y})`;
            });
        }
        // Map Click Logic
        map.on("click", (e) => {
            // Je tusi link khich rahe si, tan naya node nahi banana
            if (!isDrawingLink) {
                nodes.push({ id: nodes.length, lat: e.latlng.lat, lng: e.latlng.lng });
                update();
                updateMatrix();
            }
        });
    
        map.on("mousemove", (e) => {
            if (tempLine && sourceNode !== null) {
                const startPos = map.latLngToLayerPoint([nodes[sourceNode].lat, nodes[sourceNode].lng]);
                const mousePos = map.latLngToLayerPoint(e.latlng);
                tempLine.attr("x1", startPos.x).attr("y1", startPos.y)
                        .attr("x2", mousePos.x).attr("y2", mousePos.y);
            }
        });
    
        // Je mouse map de khaali hisse te chhad ditta jaave
        map.on("mouseup", () => {
            if (tempLine) tempLine.remove();
            tempLine = null;
            setTimeout(() => { isDrawingLink = false; sourceNode = null; }, 100);
        });
    
        function updateMatrix() {
            let size = nodes.length;
            if (size === 0) return;
            let matrix = Array(size).fill(0).map(() => Array(size).fill(0));
            links.forEach(link => {
                matrix[link.source][link.target] = 1;
                matrix[link.target][link.source] = 1;
            });
            document.getElementById("matrix-output").innerHTML = matrix.map((row, i) => 
                `<div><strong>Node ${i}:</strong> [ ${row.join(" ")} ]</div>`).join("");
        }
    
        map.on("viewreset moveend", update);
    </script> -->

    <script>
        // Map aur basic settings same rehngiya
        const map = L.map("map").setView([35.966944, -86.493056], 18);
    
        L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", {
            attribution: "Tiles © Esri",
            maxZoom: 20
        }).addTo(map);
    
        let nodes = [];
        let links = [];
        let sourceNode = null;
        let tempLine = null;
        let isDrawingLink = false;
        console.log(nodes);
        L.svg().addTo(map);
        const svg = d3.select("#map").select("svg").style("pointer-events", "auto");
        const g = svg.append("g").attr("class", "leaflet-zoom-hide");
    
        // --- MAIN UPDATE FUNCTION (EH LINES SHOW KAREGA) ---
        function update() {
            // 1. Draw Links (Edges)
            const l = g.selectAll(".link").data(links);
            
            l.enter().append("line")
                .attr("class", "link")
                .style("stroke", "#ffff00")
                .style("stroke-width", "3px")
                .merge(l)
                .attr("x1", d => map.latLngToLayerPoint([nodes[d.source].lat, nodes[d.source].lng]).x)
                .attr("y1", d => map.latLngToLayerPoint([nodes[d.source].lat, nodes[d.source].lng]).y)
                .attr("x2", d => map.latLngToLayerPoint([nodes[d.target].lat, nodes[d.target].lng]).x)
                .attr("y2", d => map.latLngToLayerPoint([nodes[d.target].lat, nodes[d.target].lng]).y);
    
            // 2. Draw Nodes
            const nodeGroups = g.selectAll(".node-group").data(nodes, d => d.id);
            const enterGroups = nodeGroups.enter().append("g").attr("class", "node-group");
    
            enterGroups.append("circle")
                .attr("class", "node")
                .attr("r", 12)
                .on("mousedown", (event, d) => {
                    event.stopPropagation();
                    L.DomEvent.stopPropagation(event);
                    isDrawingLink = true;
                    sourceNode = d.id;
                    tempLine = g.append("line").attr("class", "link").style("stroke-dasharray", "5,5");
                })
                .on("mouseup", (event, d) => {
                    event.stopPropagation();
                    if (sourceNode !== null && sourceNode !== d.id) {
                        const exists = links.some(l => 
                            (l.source === sourceNode && l.target === d.id) || 
                            (l.source === d.id && l.target === sourceNode)
                        );
                        if(!exists) {
                            links.push({ source: sourceNode, target: d.id });
                            updateMatrix(); // Data update
                            update();       // EH JAROORI HAI: Line dikhan layi!
                        }
                    }
                    resetDrag();
                });
    
            enterGroups.append("text")
                .attr("dx", 16).attr("dy", 5)
                .style("fill", "#00f2ff").style("font-weight", "bold")
                .style("text-shadow", "1px 1px 2px black")
                .style("pointer-events", "none")
                .text(d => "Node " + d.id);
    
            nodeGroups.merge(enterGroups).attr("transform", d => {
                const p = map.latLngToLayerPoint([d.lat, d.lng]);
                return `translate(${p.x},${p.y})`;
            });
    
            nodeGroups.exit().remove();
        }
    
        function resetDrag() {
            if (tempLine) tempLine.remove();
            tempLine = null;
            setTimeout(() => { isDrawingLink = false; sourceNode = null; }, 100);
            update(); // Refresh
        }
    
        map.on("click", (e) => {
            if (!isDrawingLink) {
                nodes.push({ id: nodes.length, lat: e.latlng.lat, lng: e.latlng.lng });
                update();
                updateMatrix();
            }
        });
    
        map.on("mousemove", (e) => {
            if (tempLine && sourceNode !== null) {
                const startPos = map.latLngToLayerPoint([nodes[sourceNode].lat, nodes[sourceNode].lng]);
                const mousePos = map.latLngToLayerPoint(e.latlng);
                tempLine.attr("x1", startPos.x).attr("y1", startPos.y)
                        .attr("x2", mousePos.x).attr("y2", mousePos.y);
            }
        });
    
        map.on("mouseup", resetDrag);
    
        function updateMatrix() {
            let size = nodes.length;
            if (size === 0) return;
            let matrix = Array(size).fill(0).map(() => Array(size).fill(0));
            links.forEach(link => {
                if(link.source < size && link.target < size) {
                    matrix[link.source][link.target] = 1;
                    matrix[link.target][link.source] = 1;
                }
            });
            document.getElementById("matrix-output").innerHTML = matrix.map((row, i) => 
                `<div><strong>Node ${i}:</strong> [ ${row.join(" ")} ]</div>`).join("");
        }
    
        map.on("viewreset moveend", update);
    </script>


</body>
</html>
